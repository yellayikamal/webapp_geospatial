{"version":3,"sources":["../../index.ts"],"sourcesContent":["import { Feature, Point, LineString, MultiLineString } from \"geojson\";\nimport { bearing } from \"@turf/bearing\";\nimport { distance } from \"@turf/distance\";\nimport { destination } from \"@turf/destination\";\nimport { lineIntersect as lineIntersects } from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport { point, lineString, Coord, Units } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain four values: `index`: closest point was found on nth line part, `multiFeatureIndex`: closest point was found on the nth line of the `MultiLineString`, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine<G extends LineString | MultiLineString>(\n  lines: Feature<G> | G,\n  pt: Coord,\n  options: { units?: Units } = {}\n): Feature<\n  Point,\n  {\n    dist: number;\n    index: number;\n    multiFeatureIndex: number;\n    location: number;\n    [key: string]: any;\n  }\n> {\n  if (!lines || !pt) {\n    throw new Error(\"lines and pt are required arguments\");\n  }\n\n  let closestPt: Feature<\n    Point,\n    { dist: number; index: number; multiFeatureIndex: number; location: number }\n  > = point([Infinity, Infinity], {\n    dist: Infinity,\n    index: -1,\n    multiFeatureIndex: -1,\n    location: -1,\n  });\n\n  let length = 0.0;\n  flattenEach(\n    lines,\n    function (line: any, _featureIndex: number, multiFeatureIndex: number) {\n      const coords: any = getCoords(line);\n\n      for (let i = 0; i < coords.length - 1; i++) {\n        //start\n        const start: Feature<Point, { dist: number }> = point(coords[i]);\n        start.properties.dist = distance(pt, start, options);\n        //stop\n        const stop: Feature<Point, { dist: number }> = point(coords[i + 1]);\n        stop.properties.dist = distance(pt, stop, options);\n        // sectionLength\n        const sectionLength = distance(start, stop, options);\n        //perpendicular\n        const heightDistance = Math.max(\n          start.properties.dist,\n          stop.properties.dist\n        );\n        const direction = bearing(start, stop);\n        const perpendicularPt1 = destination(\n          pt,\n          heightDistance,\n          direction + 90,\n          options\n        );\n        const perpendicularPt2 = destination(\n          pt,\n          heightDistance,\n          direction - 90,\n          options\n        );\n        const intersect = lineIntersects(\n          lineString([\n            perpendicularPt1.geometry.coordinates,\n            perpendicularPt2.geometry.coordinates,\n          ]),\n          lineString([start.geometry.coordinates, stop.geometry.coordinates])\n        );\n        let intersectPt:\n          | Feature<\n              Point,\n              { dist: number; multiFeatureIndex: number; location: number }\n            >\n          | undefined;\n\n        if (intersect.features.length > 0 && intersect.features[0]) {\n          intersectPt = {\n            ...intersect.features[0],\n            properties: {\n              dist: distance(pt, intersect.features[0], options),\n              multiFeatureIndex: multiFeatureIndex,\n              location:\n                length + distance(start, intersect.features[0], options),\n            },\n          };\n        }\n\n        if (start.properties.dist < closestPt.properties.dist) {\n          closestPt = {\n            ...start,\n            properties: {\n              ...start.properties,\n              index: i,\n              multiFeatureIndex: multiFeatureIndex,\n              location: length,\n            },\n          };\n        }\n\n        if (stop.properties.dist < closestPt.properties.dist) {\n          closestPt = {\n            ...stop,\n            properties: {\n              ...stop.properties,\n              index: i + 1,\n              multiFeatureIndex: multiFeatureIndex,\n              location: length + sectionLength,\n            },\n          };\n        }\n\n        if (\n          intersectPt &&\n          intersectPt.properties.dist < closestPt.properties.dist\n        ) {\n          closestPt = {\n            ...intersectPt,\n            properties: { ...intersectPt.properties, index: i },\n          };\n        }\n        // update length\n        length += sectionLength;\n      }\n    }\n  );\n\n  return closestPt;\n}\n\nexport { nearestPointOnLine };\nexport default nearestPointOnLine;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AACA,SAAS,eAAe;AACxB,SAAS,gBAAgB;AACzB,SAAS,mBAAmB;AAC5B,SAAS,iBAAiB,sBAAsB;AAChD,SAAS,mBAAmB;AAC5B,SAAS,OAAO,kBAAgC;AAChD,SAAS,iBAAiB;AA4B1B,SAAS,mBACP,OACA,IACA,UAA6B,CAAC,GAU9B;AACA,MAAI,CAAC,SAAS,CAAC,IAAI;AACjB,UAAM,IAAI,MAAM,qCAAqC;AAAA,EACvD;AAEA,MAAI,YAGA,MAAM,CAAC,UAAU,QAAQ,GAAG;AAAA,IAC9B,MAAM;AAAA,IACN,OAAO;AAAA,IACP,mBAAmB;AAAA,IACnB,UAAU;AAAA,EACZ,CAAC;AAED,MAAI,SAAS;AACb;AAAA,IACE;AAAA,IACA,SAAU,MAAW,eAAuB,mBAA2B;AACrE,YAAM,SAAc,UAAU,IAAI;AAElC,eAAS,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAK;AAE1C,cAAM,QAA0C,MAAM,OAAO,CAAC,CAAC;AAC/D,cAAM,WAAW,OAAO,SAAS,IAAI,OAAO,OAAO;AAEnD,cAAM,OAAyC,MAAM,OAAO,IAAI,CAAC,CAAC;AAClE,aAAK,WAAW,OAAO,SAAS,IAAI,MAAM,OAAO;AAEjD,cAAM,gBAAgB,SAAS,OAAO,MAAM,OAAO;AAEnD,cAAM,iBAAiB,KAAK;AAAA,UAC1B,MAAM,WAAW;AAAA,UACjB,KAAK,WAAW;AAAA,QAClB;AACA,cAAM,YAAY,QAAQ,OAAO,IAAI;AACrC,cAAM,mBAAmB;AAAA,UACvB;AAAA,UACA;AAAA,UACA,YAAY;AAAA,UACZ;AAAA,QACF;AACA,cAAM,mBAAmB;AAAA,UACvB;AAAA,UACA;AAAA,UACA,YAAY;AAAA,UACZ;AAAA,QACF;AACA,cAAM,YAAY;AAAA,UAChB,WAAW;AAAA,YACT,iBAAiB,SAAS;AAAA,YAC1B,iBAAiB,SAAS;AAAA,UAC5B,CAAC;AAAA,UACD,WAAW,CAAC,MAAM,SAAS,aAAa,KAAK,SAAS,WAAW,CAAC;AAAA,QACpE;AACA,YAAI;AAOJ,YAAI,UAAU,SAAS,SAAS,KAAK,UAAU,SAAS,CAAC,GAAG;AAC1D,wBAAc,iCACT,UAAU,SAAS,CAAC,IADX;AAAA,YAEZ,YAAY;AAAA,cACV,MAAM,SAAS,IAAI,UAAU,SAAS,CAAC,GAAG,OAAO;AAAA,cACjD;AAAA,cACA,UACE,SAAS,SAAS,OAAO,UAAU,SAAS,CAAC,GAAG,OAAO;AAAA,YAC3D;AAAA,UACF;AAAA,QACF;AAEA,YAAI,MAAM,WAAW,OAAO,UAAU,WAAW,MAAM;AACrD,sBAAY,iCACP,QADO;AAAA,YAEV,YAAY,iCACP,MAAM,aADC;AAAA,cAEV,OAAO;AAAA,cACP;AAAA,cACA,UAAU;AAAA,YACZ;AAAA,UACF;AAAA,QACF;AAEA,YAAI,KAAK,WAAW,OAAO,UAAU,WAAW,MAAM;AACpD,sBAAY,iCACP,OADO;AAAA,YAEV,YAAY,iCACP,KAAK,aADE;AAAA,cAEV,OAAO,IAAI;AAAA,cACX;AAAA,cACA,UAAU,SAAS;AAAA,YACrB;AAAA,UACF;AAAA,QACF;AAEA,YACE,eACA,YAAY,WAAW,OAAO,UAAU,WAAW,MACnD;AACA,sBAAY,iCACP,cADO;AAAA,YAEV,YAAY,iCAAK,YAAY,aAAjB,EAA6B,OAAO,EAAE;AAAA,UACpD;AAAA,QACF;AAEA,kBAAU;AAAA,MACZ;AAAA,IACF;AAAA,EACF;AAEA,SAAO;AACT;AAGA,IAAO,qCAAQ;","names":[]}